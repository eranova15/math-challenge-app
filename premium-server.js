// The Hypothetical Game - Premium Server\n// Scalable architecture with monetization-first approach\n\nconst express = require('express');\nconst http = require('http');\nconst socketIo = require('socket.io');\nconst cors = require('cors');\nconst helmet = require('helmet');\nconst { createClient } = require('redis');\nconst { v4: uuidv4 } = require('uuid');\nconst stripe = require('stripe')(process.env.STRIPE_SECRET_KEY);\nrequire('dotenv').config();\n\nconst app = express();\nconst server = http.createServer(app);\n\n// CORS configuration for multiple domains\nconst allowedOrigins = [\n    process.env.CLIENT_URL || \"http://localhost:3001\",\n    \"https://thehypotheticalgame.com\",\n    \"https://www.thehypotheticalgame.com\",\n    \"https://*.railway.app\",\n    \"https://*.vercel.app\"\n];\n\nconst io = socketIo(server, {\n    cors: {\n        origin: (origin, callback) => {\n            if (!origin) return callback(null, true);\n            \n            const isAllowed = allowedOrigins.some(pattern => {\n                if (pattern.includes('*')) {\n                    const regex = new RegExp(pattern.replace('*', '.*'));\n                    return regex.test(origin);\n                }\n                return pattern === origin;\n            });\n            \n            callback(null, isAllowed);\n        },\n        methods: [\"GET\", \"POST\"],\n        credentials: true\n    }\n});\n\n// Redis client for user sessions and game data\nlet redisClient = null;\nlet redisConnected = false;\n\nasync function createRedisClient() {\n    if (!process.env.REDIS_URL) {\n        console.log('⚠️  No REDIS_URL found - using memory storage');\n        return null;\n    }\n    \n    try {\n        const client = createClient({\n            url: process.env.REDIS_URL,\n            socket: {\n                connectTimeout: 5000,\n                commandTimeout: 3000,\n                lazyConnect: true\n            }\n        });\n        \n        client.on('error', (err) => {\n            console.error('Redis connection error:', err.message);\n            redisConnected = false;\n        });\n        \n        client.on('connect', () => {\n            console.log('✅ Connected to Redis - full features enabled');\n            redisConnected = true;\n        });\n        \n        return client;\n    } catch (error) {\n        console.error('Failed to create Redis client:', error.message);\n        return null;\n    }\n}\n\n// Middleware\napp.use(helmet({\n    contentSecurityPolicy: {\n        directives: {\n            defaultSrc: [\"'self'\"],\n            styleSrc: [\"'self'\", \"'unsafe-inline'\", \"https://fonts.googleapis.com\"],\n            scriptSrc: [\"'self'\", \"https://js.stripe.com\", \"https://plausible.io\"],\n            fontSrc: [\"'self'\", \"https://fonts.gstatic.com\"],\n            connectSrc: [\"'self'\", \"https://api.stripe.com\", \"https://plausible.io\"],\n            frameSrc: [\"https://js.stripe.com\"]\n        }\n    }\n}));\n\napp.use(cors({\n    origin: allowedOrigins,\n    credentials: true\n}));\n\napp.use(express.json({ limit: '10mb' }));\napp.use(express.static('.'));\n\n// Constants\nconst SUBSCRIPTION_PLANS = {\n    basic: {\n        priceId: process.env.STRIPE_BASIC_PRICE_ID,\n        price: 1200, // $12.00 in cents\n        name: 'Basic Plan',\n        features: ['unlimited_games', 'progress_tracking', 'basic_multiplayer', 'email_support']\n    },\n    premium: {\n        priceId: process.env.STRIPE_PREMIUM_PRICE_ID,\n        price: 2500, // $25.00 in cents\n        name: 'Premium Family Plan',\n        features: ['all_basic', 'family_accounts', 'ai_difficulty', 'advanced_analytics', 'priority_tournaments', 'priority_support']\n    }\n};\n\n// User Management Class\nclass UserManager {\n    constructor(redisClient) {\n        this.redis = redisClient;\n        this.memoryStore = new Map(); // Fallback when Redis unavailable\n    }\n    \n    async saveUser(userData) {\n        const userKey = `user:${userData.id || userData.email}`;\n        const userJson = JSON.stringify({\n            ...userData,\n            lastUpdated: new Date().toISOString()\n        });\n        \n        if (this.redis && redisConnected) {\n            await this.redis.setEx(userKey, 86400 * 30, userJson); // 30 days\n        } else {\n            this.memoryStore.set(userKey, userJson);\n        }\n    }\n    \n    async getUser(userId) {\n        const userKey = `user:${userId}`;\n        \n        let userData;\n        if (this.redis && redisConnected) {\n            userData = await this.redis.get(userKey);\n        } else {\n            userData = this.memoryStore.get(userKey);\n        }\n        \n        return userData ? JSON.parse(userData) : null;\n    }\n    \n    async saveGameSession(sessionData) {\n        const sessionKey = `session:${sessionData.userId}:${Date.now()}`;\n        const sessionJson = JSON.stringify(sessionData);\n        \n        if (this.redis && redisConnected) {\n            await this.redis.setEx(sessionKey, 86400 * 7, sessionJson); // 7 days\n        }\n    }\n    \n    async getUserStats(userId) {\n        const user = await this.getUser(userId);\n        if (!user) return null;\n        \n        return {\n            totalGamesPlayed: user.gamesPlayed || 0,\n            totalXP: user.totalXP || 0,\n            currentStreak: user.currentStreak || 0,\n            bestStreak: user.bestStreak || 0,\n            averageAccuracy: user.accuracy || 0,\n            subscriptionPlan: user.plan || 'free',\n            achievements: user.achievements || []\n        };\n    }\n}\n\n// Game Analytics Class\nclass GameAnalytics {\n    constructor(redisClient) {\n        this.redis = redisClient;\n    }\n    \n    async trackEvent(eventName, properties = {}) {\n        const eventData = {\n            event: eventName,\n            properties,\n            timestamp: new Date().toISOString(),\n            id: uuidv4()\n        };\n        \n        if (this.redis && redisConnected) {\n            await this.redis.lpush('analytics:events', JSON.stringify(eventData));\n            await this.redis.ltrim('analytics:events', 0, 9999); // Keep last 10k events\n        }\n        \n        console.log('📊 Analytics:', eventName, properties);\n    }\n    \n    async getDailyStats() {\n        // Implementation for daily analytics dashboard\n        return {\n            totalUsers: 0,\n            activeUsers: 0,\n            gamesPlayed: 0,\n            conversionRate: 0,\n            revenue: 0\n        };\n    }\n}\n\n// Initialize managers\nlet userManager;\nlet gameAnalytics;\n\n// API Routes\n\n// Health check\napp.get('/health', (req, res) => {\n    res.json({ \n        status: 'OK', \n        timestamp: new Date().toISOString(),\n        uptime: process.uptime(),\n        redis: redisConnected,\n        environment: process.env.NODE_ENV || 'development'\n    });\n});\n\n// User registration/login\napp.post('/api/user/register', async (req, res) => {\n    try {\n        const { name, email } = req.body;\n        \n        if (!name) {\n            return res.status(400).json({ error: 'Name is required' });\n        }\n        \n        const userId = email || `user_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n        \n        const userData = {\n            id: userId,\n            name,\n            email: email || null,\n            plan: 'free',\n            gamesPlayed: 0,\n            totalXP: 0,\n            currentStreak: 0,\n            bestStreak: 0,\n            accuracy: 0,\n            achievements: [],\n            createdAt: new Date().toISOString(),\n            lastActive: new Date().toISOString()\n        };\n        \n        await userManager.saveUser(userData);\n        await gameAnalytics.trackEvent('user_registered', { userId, hasEmail: !!email });\n        \n        res.json({ \n            success: true, \n            user: userData,\n            message: 'User registered successfully'\n        });\n        \n    } catch (error) {\n        console.error('Registration error:', error);\n        res.status(500).json({ error: 'Registration failed' });\n    }\n});\n\n// Get user profile\napp.get('/api/user/:userId', async (req, res) => {\n    try {\n        const { userId } = req.params;\n        const user = await userManager.getUser(userId);\n        \n        if (!user) {\n            return res.status(404).json({ error: 'User not found' });\n        }\n        \n        res.json({ user });\n        \n    } catch (error) {\n        console.error('User fetch error:', error);\n        res.status(500).json({ error: 'Failed to fetch user' });\n    }\n});\n\n// Save game session\napp.post('/api/game/session', async (req, res) => {\n    try {\n        const sessionData = req.body;\n        \n        // Update user stats\n        const user = await userManager.getUser(sessionData.userId);\n        if (user) {\n            user.gamesPlayed = (user.gamesPlayed || 0) + 1;\n            user.totalXP = (user.totalXP || 0) + (sessionData.score || 0);\n            user.accuracy = sessionData.accuracy || user.accuracy;\n            user.currentStreak = sessionData.currentStreak || 0;\n            user.bestStreak = Math.max(user.bestStreak || 0, sessionData.currentStreak || 0);\n            user.lastActive = new Date().toISOString();\n            \n            await userManager.saveUser(user);\n        }\n        \n        // Save session for analytics\n        await userManager.saveGameSession(sessionData);\n        await gameAnalytics.trackEvent('game_completed', sessionData);\n        \n        res.json({ success: true });\n        \n    } catch (error) {\n        console.error('Session save error:', error);\n        res.status(500).json({ error: 'Failed to save session' });\n    }\n});\n\n// Stripe webhook endpoint\napp.post('/api/stripe/webhook', express.raw({type: 'application/json'}), async (req, res) => {\n    const sig = req.headers['stripe-signature'];\n    \n    try {\n        const event = stripe.webhooks.constructEvent(\n            req.body, \n            sig, \n            process.env.STRIPE_WEBHOOK_SECRET\n        );\n        \n        switch (event.type) {\n            case 'checkout.session.completed':\n                const session = event.data.object;\n                await handleSuccessfulPayment(session);\n                break;\n                \n            case 'customer.subscription.updated':\n            case 'customer.subscription.deleted':\n                const subscription = event.data.object;\n                await handleSubscriptionChange(subscription);\n                break;\n                \n            default:\n                console.log(`Unhandled event type: ${event.type}`);\n        }\n        \n        res.json({ received: true });\n        \n    } catch (error) {\n        console.error('Webhook error:', error);\n        res.status(400).json({ error: 'Webhook signature verification failed' });\n    }\n});\n\n// Create Stripe checkout session\napp.post('/api/create-checkout-session', async (req, res) => {\n    try {\n        const { priceId, userEmail, userName } = req.body;\n        \n        const plan = Object.values(SUBSCRIPTION_PLANS).find(p => p.priceId === priceId);\n        if (!plan) {\n            return res.status(400).json({ error: 'Invalid plan selected' });\n        }\n        \n        const session = await stripe.checkout.sessions.create({\n            payment_method_types: ['card'],\n            line_items: [{\n                price: priceId,\n                quantity: 1,\n            }],\n            mode: 'subscription',\n            success_url: `${process.env.CLIENT_URL || 'http://localhost:3001'}/success?session_id={CHECKOUT_SESSION_ID}`,\n            cancel_url: `${process.env.CLIENT_URL || 'http://localhost:3001'}/cancel`,\n            customer_email: userEmail,\n            metadata: {\n                userName: userName,\n                userEmail: userEmail\n            }\n        });\n        \n        await gameAnalytics.trackEvent('checkout_initiated', {\n            plan: plan.name,\n            price: plan.price,\n            userEmail,\n            userName\n        });\n        \n        res.json({ sessionId: session.id });\n        \n    } catch (error) {\n        console.error('Checkout creation error:', error);\n        res.status(500).json({ error: 'Failed to create checkout session' });\n    }\n});\n\n// Get subscription plans\napp.get('/api/subscription/plans', (req, res) => {\n    res.json({ plans: SUBSCRIPTION_PLANS });\n});\n\n// Analytics endpoint (admin only)\napp.get('/api/analytics/dashboard', async (req, res) => {\n    try {\n        // Add authentication middleware in production\n        const stats = await gameAnalytics.getDailyStats();\n        res.json(stats);\n    } catch (error) {\n        console.error('Analytics error:', error);\n        res.status(500).json({ error: 'Failed to fetch analytics' });\n    }\n});\n\n// Serve premium frontend\napp.get('/', (req, res) => {\n    res.sendFile(__dirname + '/premium-index.html');\n});\n\napp.get('/success', (req, res) => {\n    res.sendFile(__dirname + '/success.html');\n});\n\napp.get('/cancel', (req, res) => {\n    res.sendFile(__dirname + '/cancel.html');\n});\n\n// Socket.io for real-time features\nio.on('connection', (socket) => {\n    console.log(`🔗 User connected: ${socket.id}`);\n    \n    socket.on('join-game-room', async (data) => {\n        const { userId, gameMode } = data;\n        const roomId = `${gameMode}_${Math.floor(Date.now() / 60000)}`; // 1-minute room cycles\n        \n        socket.join(roomId);\n        socket.emit('room-joined', { roomId });\n        \n        // Notify other players\n        socket.to(roomId).emit('player-joined', { userId });\n        \n        await gameAnalytics.trackEvent('multiplayer_room_joined', { userId, roomId, gameMode });\n    });\n    \n    socket.on('game-action', async (data) => {\n        const { roomId, action, payload } = data;\n        \n        // Broadcast to room\n        socket.to(roomId).emit('game-action', { action, payload, fromUser: socket.id });\n        \n        await gameAnalytics.trackEvent('multiplayer_action', { roomId, action });\n    });\n    \n    socket.on('disconnect', () => {\n        console.log(`🔌 User disconnected: ${socket.id}`);\n    });\n});\n\n// Helper functions\nasync function handleSuccessfulPayment(session) {\n    try {\n        const { customer_email, metadata } = session;\n        const userId = customer_email || metadata.userEmail;\n        \n        if (!userId) {\n            console.error('No user identifier in successful payment session');\n            return;\n        }\n        \n        // Update user subscription\n        const user = await userManager.getUser(userId);\n        if (user) {\n            // Determine plan from session\n            const subscription = await stripe.subscriptions.retrieve(session.subscription);\n            const priceId = subscription.items.data[0].price.id;\n            \n            let planType = 'basic';\n            if (priceId === SUBSCRIPTION_PLANS.premium.priceId) {\n                planType = 'premium';\n            }\n            \n            user.plan = planType;\n            user.subscriptionId = session.subscription;\n            user.subscriptionStatus = 'active';\n            user.subscriptionUpdated = new Date().toISOString();\n            \n            await userManager.saveUser(user);\n            \n            await gameAnalytics.trackEvent('subscription_activated', {\n                userId,\n                plan: planType,\n                subscriptionId: session.subscription\n            });\n            \n            console.log(`✅ Subscription activated for user ${userId}: ${planType}`);\n        }\n        \n    } catch (error) {\n        console.error('Error handling successful payment:', error);\n    }\n}\n\nasync function handleSubscriptionChange(subscription) {\n    try {\n        const customer = await stripe.customers.retrieve(subscription.customer);\n        const userId = customer.email;\n        \n        if (!userId) return;\n        \n        const user = await userManager.getUser(userId);\n        if (user) {\n            user.subscriptionStatus = subscription.status;\n            \n            if (subscription.status === 'canceled' || subscription.status === 'unpaid') {\n                user.plan = 'free';\n            }\n            \n            user.subscriptionUpdated = new Date().toISOString();\n            await userManager.saveUser(user);\n            \n            await gameAnalytics.trackEvent('subscription_changed', {\n                userId,\n                status: subscription.status,\n                subscriptionId: subscription.id\n            });\n        }\n        \n    } catch (error) {\n        console.error('Error handling subscription change:', error);\n    }\n}\n\n// Server startup\nasync function startServer() {\n    const startTime = Date.now();\n    \n    try {\n        console.log('🚀 Starting The Hypothetical Game Server...');\n        console.log(`📍 Platform: ${process.platform}, Node: ${process.version}`);\n        \n        // Initialize Redis\n        redisClient = await createRedisClient();\n        if (redisClient) {\n            try {\n                await redisClient.connect();\n                console.log('✅ Redis connected - full features enabled');\n            } catch (error) {\n                console.warn('⚠️  Redis connection failed - using memory storage:', error.message);\n                redisClient = null;\n            }\n        }\n        \n        // Initialize managers\n        userManager = new UserManager(redisClient);\n        gameAnalytics = new GameAnalytics(redisClient);\n        \n        // Start HTTP server\n        const PORT = process.env.PORT || 3001;\n        console.log(`🔌 Binding to PORT: ${PORT}`);\n        \n        server.listen(PORT, '0.0.0.0', () => {\n            const startupTime = Date.now() - startTime;\n            console.log(`✅ The Hypothetical Game Server ONLINE on port ${PORT} (${startupTime}ms)`);\n            console.log(`📡 WebSocket server ready for real-time features`);\n            console.log(`🏠 Serving premium frontend from current directory`);\n            console.log(`🌍 Environment: ${process.env.NODE_ENV || 'development'}`);\n            console.log(`💳 Stripe integration: ${process.env.STRIPE_SECRET_KEY ? 'ENABLED' : 'DISABLED'}`);\n            console.log(`📊 Analytics: ENABLED`);\n        });\n        \n        // Track server startup\n        setTimeout(() => {\n            gameAnalytics.trackEvent('server_started', {\n                startupTime,\n                environment: process.env.NODE_ENV || 'development',\n                redisConnected\n            });\n        }, 1000);\n        \n    } catch (error) {\n        console.error('❌ Failed to start server:', error);\n        process.exit(1);\n    }\n}\n\n// Graceful shutdown\nprocess.on('SIGTERM', async () => {\n    console.log('🛑 SIGTERM received, shutting down gracefully...');\n    \n    server.close(async () => {\n        console.log('📡 HTTP server closed');\n        \n        if (redisClient) {\n            try {\n                await redisClient.quit();\n                console.log('🔌 Redis connection closed');\n            } catch (error) {\n                console.error('Error closing Redis:', error.message);\n            }\n        }\n        \n        console.log('✅ Graceful shutdown complete');\n        process.exit(0);\n    });\n    \n    setTimeout(() => {\n        console.log('⏰ Force exit after timeout');\n        process.exit(1);\n    }, 10000);\n});\n\nprocess.on('SIGINT', async () => {\n    console.log('🛑 SIGINT received, shutting down gracefully...');\n    \n    server.close(async () => {\n        if (redisClient) {\n            try {\n                await redisClient.quit();\n            } catch (error) {\n                console.error('Error closing Redis:', error.message);\n            }\n        }\n        process.exit(0);\n    });\n});\n\nprocess.on('uncaughtException', (error) => {\n    console.error('❌ Uncaught Exception:', error);\n    process.exit(1);\n});\n\nprocess.on('unhandledRejection', (reason, promise) => {\n    console.error('❌ Unhandled Rejection at:', promise, 'reason:', reason);\n    process.exit(1);\n});\n\n// Start the server\nstartServer();"